---
title: 算法：第一次算法比赛的自我复盘
date: 2023-11-21 11:33:00
categories: 算法
tags: [算法题,算法]
---
2023/11/18.第一次打算法比赛，还是感受到自己在算法的学习中有很多地方不足，好在是自己意识到了。题目做的还是太少了，多说无益，还是得练！(大佬就别看了，蒻拘的自我复盘罢了orz)
题外话：我学习的Java，最后我选择用打java来打算法比赛。在学校数据结构还有平时的练习中，我感到这条路并不好走，市面上很多非常优秀的题解都是C++的，我希望通过写博客一方面给我自己好好复盘，慢慢进步，另一方面我希望给将来需要的人一个参考，让需要的人可以少花一点时间在查找题解上。（当然仅仅是分享我小白的愚见罢了）。自己在这方面的学习还是很浅淡，关于算法复盘的博客会持续更新，每一道题实际上都可以再深究，我会持续补充自己的题解，复盘之余也发现了自己需要多多做题才是。(期末了任务太多了，实在是顾不过来~~~，orz）

<!--more-->

##爬楼梯

[题目链接][1]
![img1.PNG][2]

### Acwing解法一
当时我想到的就是这种，我服了，没有处理好条件。

```java
import java.io.*;
import java.util.*;
public class Main{
    static int N = 100;
    static int Int(String s){return Integer.parseInt(s);}
    public static void main(String[] args)throws IOException{
        BufferedReader br  =new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int n = Int(br.readLine());
        int ans = fn(n);
        bw.write(Integer.toString(ans));
        
        bw.close();br.close();bw.close();
    }
    static int fn(int n){
        if(n == 0) return 1;
        else if(n < 0) return 0;
        else return fn(n - 1) + fn( n -2);
    }
}
```

意外之余我还发现了一种方式

```java
import java.io.*;
import java.util.*;
public class Main{
    static int N = 100;
    static int Int(String s){return Integer.parseInt(s);}
    public static void main(String[] args)throws IOException{
        BufferedReader br  =new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int n = Int(br.readLine());
        int ans = fn(n);
        bw.write(Integer.toString(ans));
        
        bw.close();br.close();bw.close();
    }
    static int fn(int n){
        if(n == 1) return 1;
        else if( n == 2) return 2;
        else if(n < 0) return 0;
        else return fn(n - 1) + fn( n -2);
    }
}
```

在第一种方式的基础上其实上也好理解，但是Acwing上两个时间差不多

但是这两种放到LeetCode上面就会超时，然后我又学习了另一种方式。

这种方法的**时间复杂度为O(2^n^)**，是一种树形的结构，**在计算第三级台阶和第四级台阶的时候，我们都计算了第二级台阶的方法，为了减少重复，我们可以通过记忆化递归的方法来避免这部分重复的计算**。

### 动态规划

我们记录了全部n个状态，但是其实只有**两个状态在更新下一个状态的时候会被用到**。如果只记录这两个状态，我们就可以将**空间复杂度从O(n)**优化到**O(1)**

```java
import java.io.*;
import java.util.*;
public class Main{
    static int N = 100;
    static int Int(String s){return Integer.parseInt(s);}
    public static void main(String[] args)throws IOException{
        BufferedReader br  =new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int n = Int(br.readLine());
        int ans = fn(n);
        bw.write(Integer.toString(ans));
        
        bw.close();br.close();bw.close();
    }
    public static int fn(int n){
      //当只爬一级台阶的时候，返回1表示只有1种方案
      if(n == 1) return 1;
      //爬到每一级台阶的方法可以看作是一个状态，我们用一个数组来记录这个状态
      int[] arr = new int[n + 1];
      //爬第一级一种方案 ，第二级两种方案
      arr[1] = 1; arr[2] = 2;
      //我们从1到n依次更新每种状态
      for(int i = 3; i<= n ;i ++){
          //每次爬台阶都是前两次爬台阶结果方案的和
          arr[i] = arr[i- 1] + arr[i-2];
      }
      //返回爬n阶台阶最后的方案数
      return arr[n];
    }
}
```


----------

##搜索插入位置

[题目链接][3]
![img2.PNG][4]

### 左二分

左二分查找第一个满足条件的位置

背一遍板子就行了，然后写两个**额外的if**，特判一下，不然边界情况找不到不会输出，比赛的时候我没写两个判断，板子背熟了题做太少了

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0; int n = nums.length; int r = n - 1;
        while(l < r){
            int mid = l + r >>1;
            if(nums[mid] >= target) r = mid;
            else l = mid  + 1;
        }
        if(l == nums.length - 1 && nums[l] < target) return nums.length;
        if(l == 0 && nums[l] > target) return 0;
        return l;
    }
}
```

----------

##快乐数
[题目链接][5]
![img3.PNG][6]
### 快慢指针

使用一个 [label color="red"]快慢指针[/label] ，像两个运动员，通过反复调用方法，得到的是一个 [label color="red"]隐形的链表[/label] ，形参中的n，作为链表中的头结点，链表中其他数字都是结点，ne指针通过调用 [label color="blue"]getSquare函数[/label] 获得。

比赛的时候我想到了求取一个数的每个位置的平方和，但是我想不到怎么在求取完之后，继续再次求取当前结果的各位平方和(我是用的while，我想不懂怎么处理结束，连方法调用都没想到 ToT ),这个方法确实太巧妙了。

```java
class Solution {
    public boolean isHappy(int n) {
        //判断n是不是快乐数字，用n作为起点
        int slowRunner = n;
        //默认让快指针先走一步
        int fastRunner = getSquare(n);
        //循环赛跑
        //如果n是一个快乐数，没有循环，那么意味着快指针会比慢指针先到达数字1
        //如果n不是一个快乐数，将会在连续的 求取每位的平方和-替换 的过程中形成一个环，那么快指针永远比慢指针多跑
        //我们将快指针各个位置求取两次平方和，慢指针每个位置求取一次平方和，这样如果不是一个快乐数，那么总有一次快指针会追上慢指针在同一个数字上相遇。
        //如果快指针没有找到1，或者是没有重合，那么就一直求取平方和
        while(faseRunner != 1 && fastRunner != slowRunner){
            slowRunner = getSquare(slowRunner);
            fastRunner = getSquare(getSquare(fastRunner));
        }
        //如果找到了慢指针相遇 ， 即fastRunner == slowRunner 返回false。否则将返回true
        return fastRunner == 1;
    }
    //根据快乐数定义，求取当前n这个数字的各位平方和
    public static int getSquare(int n){
        int  ans = 0;
        while( n > 0){
            int t = n % 10;
            n /= 10;
            ans += t * t;
        }
        return ans;
    }
}
```

----------

##去除重复字母
[题目链接][7]
![img4.PNG][8]
###单调栈

这里我们不光需要使用单调栈的模板，而且为了维护单调栈的特性，我们还需要维护其他另外两个数组，一个用来标记栈中有没有这个字母，另一个数组用来统计这个字母有没有用完。

```java
class Solution {
    //数据规模
    public static int N = 100010;
    //使用手写的方式模拟一个栈
    public static char[] stk = new char[N];
    public static int tt = 0;
    public String removeDuplicateLetters(String s) {
        //存储当前字母所在一共有多少个
        int[] cnt = new int[N];
        //判断当前字母在栈中有无重复
        boolean[] st = new boolean[30];
        //遍历字符串，先获取当前每个字母的总次数
        for(int i = 0 ; i< s.length(); i++) cnt[s.charAt(i) - 'a']++ ;
        
        for(int i= 0 ; i< s.length();i++){
            char c = s.charAt(i) ;
            //将当前遍历到的字母次数 - 1
            cnt[c - 'a']--;
            //如果栈中已经有字母了，那么直接返回，不做任何操作
            if(st[c - 'a']) continue;
            //使用单调栈来维护
            //判断当前栈不空的情况下，并且当前栈顶大于当前元素，对于当前字母还有次数没有使用
            while(!isEmpty() && peak() > c && cnt[peak()- 'a'] > 0){
                //弹出栈顶元素，直到符合当前元素大于栈中所有的元素为主
                st[peak() - 'a'] = false;
                pop();
            }
            //将其加入
            push(c);
            //并标记为加入
            st[c- 'a'] = true;
            
        }
        //输出栈中元素
        StringBuilder sb = new StringBuilder();
        while(!isEmpty()){
            sb.append(peak());
            pop();
        }
        sb.reverse();
        return sb.toString();
        
    }
    public static boolean isEmpty(){
        return tt <= 0;
    }
    public static char peak(){
        return stk[tt];
    }
    public static void pop(){
        tt--;
    }
    public static void push(char ch){
        stk[++tt] = ch;
    }
}
```
##前四道题视频简单复盘
对于前四道题，我自己也录有视频，用以简单复盘，留作纪念，自己对于题解还是理解的很肤浅，(大佬请跳过orz)。
[video title="前四道题视频复盘 " url="https://img.kaijavademo.top/typecho/uploads/2023/11/%E8%A7%86%E9%A2%91%E5%A4%8D%E7%9B%98.mkv " container="bpxmm1uc4x" subtitle=" " poster=" "] [/video]

----------
我书写这篇文章的初衷就是总结学习的进度，遗忘之际可以拿出来翻看，如有不对的地方还望指正，多多海涵。

  [1]: https://leetcode.cn/problems/climbing-stairs/description/
  [2]: https://img.kaijavademo.top/typecho/uploads/2023/11/2492607706.png
  [3]: https://leetcode.cn/problems/N6YdxV/description/
  [4]: https://img.kaijavademo.top/typecho/uploads/2023/11/3402024912.png
  [5]: https://leetcode.cn/problems/happy-number/description/
  [6]: https://img.kaijavademo.top/typecho/uploads/2023/11/1534872893.png
  [7]: https://leetcode.cn/problems/remove-duplicate-letters/description/
  [8]: https://img.kaijavademo.top/typecho/uploads/2023/11/275962736.png